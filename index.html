<!DOCTYPE HTML>
<!--
  ** Two-Dimensional Additive Cellular Automata with Modular Arithmetics (Web Application)
  ** Copyright (c) 2014 Sergey Shishmintzev
  ** License: MIT
  ** GitHub Project: http://github.com/x-or/tdacawam
  -->
<html>
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Two-Dimensional Additive Cellular Automata with Arbitrary Modulus</title>
    <style type="text/css">
      div.container {
        margin-left: auto;
        margin-right: auto;
        margin-top: none;
        margin-bottom: none;
      }

      div.rule-column {
        /*width: 130px;*/
        float: left;
      }

      div.view-column {
        float: left;
      }

      div.clear {
        clear: both;
      }

      table.rule-layout {
        margin-right: 10px;
        border: 1px solid #000;
        border-collapse: collapse;
      }

      table.rule-layout td {
        border: 1px solid #000;
        text-align: center;
        padding: 3px 7px 2px;
      }

      input[type="number"] {
        width:50px;
      }

      .footer {
        text-align: left;
        font-size: 13px;
        padding-top: 2em;
        padding-bottom: 2em;
      }
      .footer p {
        margin: 0px;
      }
    </style>
    <script>
      var maxCanvasSize = 4096;
      var maxModulus = 4096;
      var maxBase = 4096;

      var IndicatorStyle = {false: {}, true: {backgroundColor: "#fe0"}};

      // http://javascript.about.com/od/problemsolving/a/modulobug.htm
      Number.prototype.mod = function(n) {
        return ((this%n)+n)%n;
      }

      function assert(condition, message) {
        // http://stackoverflow.com/a/15313435/3607531
        if (!condition) {
          throw message || "Assertion failed";
       }
      }

      function createArray(length) {
        // http://stackoverflow.com/a/966938/3607531
        var arr = new Array(length || 0),
            i = length;

        if (arguments.length > 1) {
          var args = Array.prototype.slice.call(arguments, 1);
          while(i--) arr[length-1 - i] = createArray.apply(this, args);
        }

        return arr;
      }

      function digitalReverse(n, digitCount, base) {
        var r = 0;
        for (var i = 0; i < digitCount; i++) {
          r = base*r + n % base;
          n = Math.floor(n / base);
        }
        return r;
      }

      function Xreverse(n, t, b) {
        var r = 0;
        r = 2*r + n % 2;
        n = Math.floor(n / 2);
        for (var i = 0; i < t; i++) {
          r = b*r + n % b;
          n = Math.floor(n / b);
        }
        assert (n == 0, "assertion failed in Xreverse: n == 0");
        return r;
      }

      assert(digitalReverse(123, 3, 10) == 321, "digitalReverse 123");
      assert(digitalReverse(54321, 5, 10) == 12345, "digitalReverse 54321");
      assert(digitalReverse(0x123, 3, 16) == 0x321, "digitalReverse 0x123");
      assert(digitalReverse(0x54321, 5, 16) == 0x12345, "digitalReverse 0x54321");

      function patternGrouping(n, size, base) {
        // [0, 1, 2, 3] --(base=2)--> [0, 2, 1, 3]
        var blockSize = Math.floor(size/base);
        var blockNumber = Math.floor(n/blockSize);
        return (n%blockSize)*base + blockNumber;
      }

      function renderStateOnCanvas(state, state_size, canvas, color, scale){
        var context = canvas.getContext('2d');

        var imageData = context.createImageData(state_size*scale, state_size*scale);
        var pixel = imageData.data;

        var off = 0;
        var val = 0;
        var pos = 0;
        var state_row;
        if (scale == 1) {
          for (var i = 0; i < state_size; i++) {
            state_row = state[i];
            for (var j = 0; j < state_size; j++) {
              val = color[state_row[j]];
              pos = off + j*4;
              pixel[pos+0] = val[0];
              pixel[pos+1] = val[1];
              pixel[pos+2] = val[2];
              pixel[pos+3] = 255;
            }
            off += state_size*4;
          }
        } else {
          for (var i = 0; i < state_size; i++) {
            state_row = state[i];
            for (var ii = 0; ii < scale; ii++) {
              for (var j = 0; j < state_size; j++) {
                val = color[state_row[j]];
                for (var jj = 0; jj < scale; jj++) {
                  pos = off + j*scale*4 + jj*4;
                  pixel[pos+0] = val[0];
                  pixel[pos+1] = val[1];
                  pixel[pos+2] = val[2];
                  pixel[pos+3] = 255;
                }
              }
              off += state_size*scale*4;
            }
          }
        }

        context.putImageData(imageData, 0, 0);
      }

      function getMousePos(canvas, evt){
        var obj = canvas;
        var top = 0;
        var left = 0;
        while (obj && obj.tagName != 'BODY') {
          top += obj.offsetTop;
           left += obj.offsetLeft;
           obj = obj.offsetParent;
        }
        var mouseX = evt.clientX - left + window.pageXOffset;
        var mouseY = evt.clientY - top + window.pageYOffset;
        return { x: mouseX, y: mouseY };
      }

      var queryString = (function(a) {
        // http://stackoverflow.com/a/3855394/3607531
        if (a == "") return {};
        var b = {};
        for (var i = 0; i < a.length; ++i) {
          var p=a[i].split('=');
          if (p.length != 2)
            continue;
          b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
        }
        return b;
      })(window.location.search.substr(1).split('&'));

      function parseIntInRange(s, intMin, intMax) {
        return Math.min(intMax, Math.max(intMin, parseInt(s)));
      }

      function log(x, base) {
        return Math.log(x)/Math.log(base);
      }

      function isIntegerApproximation(f) {
        return Math.abs(Math.round(f) - f) < 1.e-10;
      }
    </script>
  </head>
  <body bgcolor="#efefef">
    <div id="container">
    </div>
    <script src="externals/react/react.js"></script>
    <script src="externals/react/JSXTransformer.js"></script>
    <script type="text/jsx">
      /**
       * @jsx React.DOM
       */
      var RuleCheckBox = React.createClass({
        propTypes: {
          bit: React.PropTypes.any.isRequired,
          rule: React.PropTypes.any.isRequired,
          disabled: React.PropTypes.number
        },
        getDefaultProps: function() {
          return {disabled: 0};
        },
        handleChange: function(event) {
          var value = 0;
          if (event.target.checked) {
            value = this.props.bit;
          }
          this.props.onChange({bit: this.props.bit, value: value});
        },
        render: function() {
          var checked = (this.props.rule & this.props.bit) != 0;
          var disabled = (this.props.disabled & this.props.bit) != 0;
          return <input type="checkbox" disabled={disabled} checked={checked} onChange={this.handleChange} title={this.props.bit}/>
        }
      });
      var RuleCheckGrid = React.createClass({
        propTypes: {
          rule: React.PropTypes.number.isRequired,
          disabled: React.PropTypes.number
        },
        getDefaultProps: function() {
          return {disabled: 0};
        },
        handleRuleCheckBoxChange: function(data) {
          var rule = this.props.rule;
          if (data.value != 0) {
            rule |= data.bit;
          } else {
            rule &= (~data.bit) & 511;
          }
          this.props.onChange(rule);
        },
        render: function() {
          var rule = this.props.rule;
          var disabled = this.props.disabled;
          return <table>
            <tr><td><RuleCheckBox bit={64} rule={rule} disabled={disabled} onChange={this.handleRuleCheckBoxChange} /></td>
                <td><RuleCheckBox bit={128} rule={rule} disabled={disabled} onChange={this.handleRuleCheckBoxChange} /></td>
                <td><RuleCheckBox bit={256} rule={rule} disabled={disabled} onChange={this.handleRuleCheckBoxChange} /></td></tr>
            <tr><td><RuleCheckBox bit={32} rule={rule} disabled={disabled} onChange={this.handleRuleCheckBoxChange} /></td>
                <td><RuleCheckBox bit={1} rule={rule} disabled={disabled} onChange={this.handleRuleCheckBoxChange} /></td>
                <td><RuleCheckBox bit={2} rule={rule} disabled={disabled} onChange={this.handleRuleCheckBoxChange} /></td></tr>
            <tr><td><RuleCheckBox bit={16} rule={rule} disabled={disabled} onChange={this.handleRuleCheckBoxChange} /></td>
                <td><RuleCheckBox bit={8} rule={rule} disabled={disabled} onChange={this.handleRuleCheckBoxChange} /></td>
                <td><RuleCheckBox bit={4} rule={rule} disabled={disabled} onChange={this.handleRuleCheckBoxChange} /></td></tr>
          </table>;
        }
      });
      var RuleLabel = React.createClass({
        render: function() {
          var bit = this.props.bit;
          var text = "0";
          if ((this.props.rule & bit) != 0) {
            text =  "+";
            if ((this.props.sign & bit) != 0)
              text =  "-";
          }
          return <div>{text}</div>
        }
      });
      var RuleGrid = React.createClass({
        propTypes: {
          rule: React.PropTypes.number.isRequired,
          sign: React.PropTypes.number.isRequired
        },
        render: function() {
          var rule = this.props.rule;
          var sign = this.props.sign;
          return <div>
            <div>Rule/Sign</div>
            <table className="rule-layout">
              <tr><td><RuleLabel bit={64} rule={rule} sign={sign} /></td>
                  <td><RuleLabel bit={128} rule={rule} sign={sign} /></td>
                  <td><RuleLabel bit={256} rule={rule} sign={sign} /></td></tr>
              <tr><td><RuleLabel bit={32} rule={rule} sign={sign} /></td>
                  <td><RuleLabel bit={1} rule={rule} sign={sign} /></td>
                  <td><RuleLabel bit={2} rule={rule} sign={sign} /></td></tr>
              <tr><td><RuleLabel bit={16} rule={rule} sign={sign} /></td>
                  <td><RuleLabel bit={8} rule={rule} sign={sign} /></td>
                  <td><RuleLabel bit={4} rule={rule} sign={sign} /></td></tr>
            </table>
          </div>;
        }
      });
      var RuleEditor = React.createClass({
        propTypes: {
          rule: React.PropTypes.number.isRequired,
          disabled: React.PropTypes.number
        },
        getDefaultProps: function() {
          return {disabled: 0};
        },
        handleInputChange: function(event) {
          var rule = parseInt(event.target.value);
          if (!(rule >= 0 && rule <= 511)) // FIXME
             rule = 0;
          this.props.onChange(rule);
        },
        handleRuleChange: function(rule) {
          this.props.onChange(rule);
        },
        render: function() {
          return <div>
                   <div>{this.props.type} # <input type="text" size="3" value={this.props.rule} onChange={this.handleInputChange} /></div>
                   <RuleCheckGrid rule={this.props.rule} disabled={this.props.disabled} onChange={this.handleRuleChange} />
                 </div>;
        }
      });
      var RuleSignEditor = React.createClass({
        propTypes: {
          rule: React.PropTypes.number.isRequired,
          sign: React.PropTypes.number.isRequired
        },
        handleRuleChange: function(rule) {
          this.props.onChange(rule, this.props.sign)
        },
        handleSignChange: function(sign) {
          this.props.onChange(this.props.rule, sign)
        },
        render: function() {
          var rule = this.props.rule;
          var sign = this.props.sign;
          return <div>
               <hr />
               <RuleEditor type="Rule" rule={rule} onChange={this.handleRuleChange} />
               <hr />
               <RuleEditor type="Sign" rule={sign} disabled={~rule} onChange={this.handleSignChange} />
               <hr />
               <RuleGrid rule={rule} sign={sign} />
               <hr />
               Rule bits layout:
               <table className="rule-layout">
                 <tr><td>64</td><td>128</td><td>256</td></tr>
                 <tr><td>32</td><td>1</td><td>2</td></tr>
                 <tr><td>16</td><td>8</td><td>4</td></tr>
               </table>
               <hr />
          </div>;
        }
      });

      var HidingOption = React.createClass({
        render: function() {
          if (this.props.visible) {
            return <option value={this.props.value}>{this.props.text}</option>;
          } else {
            return <option disabled={true} style={{ display: "none"}} value={this.props.value}>{this.props.text}</option>;
          }
         }
      });
      var ReactApplication = React.createClass({
        getInitialState: function() {
          var stateSize = parseIntInRange(queryString['size'], 2, maxCanvasSize) || 512;
          var state0 = createArray(stateSize, stateSize);
          var state1 = createArray(stateSize, stateSize);
          for (var i = 0; i < stateSize; i++)
            for (var j = 0; j < stateSize; j++) {
               state0[i][j] = 0;
               state1[i][j] = 0;
            }
          this.stateCells = [state0, state1];
          this.curState = 0;
          return {
            stateSize: stateSize,
            scale: parseIntInRange(queryString['scale'], 1, Math.floor(maxCanvasSize/stateSize)) || 1,
            base: parseIntInRange(queryString['base'], 2, maxBase) || 2,
            modulus: parseIntInRange(queryString['modulus'], 2, maxModulus) || 2,
            ruleStep: 0,
            patternName: queryString['pattern'] || "empty",
            rule: parseIntInRange(queryString['rule'], 0, 511) || 15,
            sign: parseIntInRange(queryString['sign'], 0, 511) || 0,
            imageDisplay: "none",
            imageSrc: "",
            isDigitReversalPermutationRowsWasApplied: false,
            isDigitReversalPermutationRowsColsWasApplied: false,
            isQuadrupleDigitReversalPermutationRowsWasApplied: false,
            isQuadrupleDigitReversalPermutationRowsColsWasApplied: false,
            patternGroupingRowsStep: 0,
            patternGroupingRowsColsStep: 0,
          };
        },
        clearState: function() {
          var stateSize = this.state.stateSize;
          var state0 = this.stateCells[0];
          var state1 = this.stateCells[1];
          for (var i = 0; i < stateSize; i++)
            for (var j = 0; j < stateSize; j++) {
               state0[i][j] = 0;
               state1[i][j] = 0;
            }
          this.setState({
            ruleStep: 0,
            isDigitReversalPermutationRowsWasApplied: false,
            isDigitReversalPermutationRowsColsWasApplied: false,
            isQuadrupleDigitReversalPermutationRowsWasApplied: false,
            isQuadrupleDigitReversalPermutationRowsColsWasApplied: false,
            patternGroupingRowsStep: 0,
            patternGroupingRowsColsStep: 0,
            // Warning: may be reset same in the handleSizeChange
          });
          return false;
        },
        renderState: function() {
          var modulus = this.state.modulus;
          var stateSize = this.state.stateSize;
          var scale = this.state.scale;
          var state = this.stateCells[this.curState];
          var color = new Array(modulus+1); // cache?
          for (var i = 0; i < modulus; i++) {
            c = Math.floor(255*i/(modulus-1));
            color[i] = [c, c, c];
          }
          color[modulus] = [255, 0, 0]; // error color
          renderStateOnCanvas(state, stateSize, this.refs.stateCanvas.getDOMNode(), color, scale);
        },
        emptyPattern: function() {
          this.clearState();
        },
        diagonalLine: function() {
          var modulus = this.state.modulus;
          var stateSize = this.state.stateSize;
          var state = this.stateCells[this.curState];
          this.clearState();
          for (var i = 0; i < stateSize; i++)
            state[i][i] = 1;
        },
        permutedDiagonaLine: function() {
          var base = this.state.base;
          var modulus = this.state.modulus;
          var stateSize = this.state.stateSize;
          var state = this.stateCells[this.curState];
          this.clearState();
          var digitCount = Math.round(log(stateSize, base));
          for (var i = 0; i < stateSize; i++)
            state[i][digitalReverse(i, digitCount, base)] = 1;
        },
        quarterPermutedDiagonaLine: function() {
          var base = this.state.base;
          var modulus = this.state.modulus;
          var stateSize = this.state.stateSize;
          if (!isIntegerApproximation(log(stateSize, base)) 
           && !isIntegerApproximation(log(Math.floor(stateSize / 2), base))) {
            throw "Incorrect state size";
          }
          if (!isIntegerApproximation(log(Math.floor(stateSize / 2), base))) {
            stateSize *= 2;
            this.setStateSize(stateSize);
            this.setState({patternName: "qpdl"});
          } else {
            this.clearState();
          }
          var halfSize = stateSize/2;
          var state = this.stateCells[this.curState];
          var digitCountOfTheHalf = Math.round(log(halfSize, base));
          for (var i = 0; i < halfSize; i++)
            state[i+halfSize][digitalReverse(i, digitCountOfTheHalf, base)+halfSize] = 1;
        },
        randomPattern: function() {
          var modulus = this.state.modulus;
          var stateSize = this.state.stateSize;
          var state = this.stateCells[this.curState];
          this.clearState();
          for (var i = 0; i < stateSize; i++)
            for (var j = 0; j < stateSize; j++)
              state[i][j] = Math.floor(Math.random() * modulus);
        },
        exclusiveOrPattern: function() {
          var modulus = this.state.modulus;
          var stateSize = this.state.stateSize;
          var state = this.stateCells[this.curState];
          this.clearState();
          for (var i = 0; i < stateSize; i++)
            for (var j = 0; j < stateSize; j++)
              state[i][j] = (i ^ j) % modulus;
        },
        modularMultiplication: function() {
          var modulus = this.state.modulus;
          var stateSize = this.state.stateSize;
          var state = this.stateCells[this.curState];
          this.clearState();
          for (var i = 0; i < stateSize; i++)
            for (var j = 0; j < stateSize; j++)
              state[i][j] = (i * j) % modulus;
        },
        manifestationOfPDL: function() {
          var base = this.state.base;
          var modulus = this.state.modulus;
          var stateSize = this.state.stateSize;
          if (!isIntegerApproximation(log(stateSize, base)) 
           && !isIntegerApproximation(log(Math.floor(stateSize / 2), base))) {
            throw "Incorrect state size";
          }
          if (!isIntegerApproximation(log(Math.floor(stateSize / 2), base))) {
            stateSize *= 2;
            this.setStateSize(stateSize);
            this.setState({patternName: "mopdl"});
          } else {
            this.clearState();
          }
          var halfSize = Math.floor(stateSize / 2);
          var digitCount = Math.round(log(halfSize, base));
          var state = this.stateCells[this.curState];
          var reversible_state = createArray(stateSize, stateSize);
          for (var i = 0; i < stateSize; i++)
            for (var j = 0; j < stateSize; j++)
              reversible_state[i][j] = 0;
          for (var i = 0; i < halfSize; i++) {
            var r = digitalReverse(i, digitCount, base);
            reversible_state[i][r] = 1;
            reversible_state[i+halfSize][r] = modulus-1;
            reversible_state[i][r+halfSize] = modulus-1;
            reversible_state[i+halfSize][r+halfSize] = 1;
          }
          var i0, i1, j0, j1;
          for (i0 = 0; i0 < stateSize-1; i0++) {
            i1 = i0 + 1;
            for (j0 = 0; j0 < stateSize-1; j0++) {
              j1 = j0 + 1;
              // solves s11 from (s00 - s01 - s10 + s11 == rs00) (mod modulus)
              state[i1][j1] = (reversible_state[i0][j0] - state[i0][j0] + state[i0][j1] + state[i1][j0] + modulus) % modulus;
            }
          }
        },
        statics: {
          patternNames: ["empty", "diagonal", "permuted-diagonal", "qpdl", "mopdl", "xor", "mulmod", "random"],
          patterns: {
            "empty": {title: "Empty", apply: function() { this.emptyPattern(); }},
            "diagonal": {title: "Diagonal Line", apply: function() { this.diagonalLine(); }},
            "permuted-diagonal": {title: "Permuted Diagonal Line (PDL)", apply: function() { this.permutedDiagonaLine(); }},
            "qpdl": {title: "Quarter Permuted Diagonal Line (QPDL)", apply: function() { this.quarterPermutedDiagonaLine(); }},
            "mopdl": { title: "Manifestation of PDL", apply: function() { this.manifestationOfPDL(); }},
            "xor": { title: "Exclusive Or", apply: function() { this.exclusiveOrPattern(); }},
            "mulmod": { title: "Modular Multiplication", apply: function() { this.modularMultiplication(); }},
            "random": {title: "Random", apply: function() { this.randomPattern(); }}
          }
        },
        setPattern: function(patternName) {
          var requestedPattern = ReactApplication.patterns[patternName];
          if (requestedPattern) {
            this.setState({patternName: patternName});
            requestedPattern.apply.bind(this)();
          }
        },
        applyRule: function() {
          var modulus = this.state.modulus;
          var stateSize = this.state.stateSize;
          var state0 = this.stateCells[this.curState];
          var state1 = this.stateCells[this.curState ^ 1];
          var rule = this.state.rule;
          var sign = this.state.sign;
          var v = 0;
          var r1 = ((rule & 1) != 0 ? 1 : 0) * ((sign & 1) != 0 ? -1 : 1);
          var r2 = ((rule & 2) != 0 ? 1 : 0) * ((sign & 2) != 0 ? -1 : 1);
          var r4 = ((rule & 4) != 0 ? 1 : 0) * ((sign & 4) != 0 ? -1 : 1);
          var r8 = ((rule & 8) != 0 ? 1 : 0) * ((sign & 8) != 0 ? -1 : 1);
          var r16 = ((rule & 16) != 0 ? 1 : 0) * ((sign & 16) != 0 ? -1 : 1);
          var r32 = ((rule & 32) != 0 ? 1 : 0) * ((sign & 32) != 0 ? -1 : 1);
          var r64 = ((rule & 64) != 0 ? 1 : 0) * ((sign & 64) != 0 ? -1 : 1);
          var r128 = ((rule & 128) != 0 ? 1 : 0) * ((sign & 128) != 0 ? -1 : 1);
          var r256 = ((rule & 256) != 0 ? 1 : 0) * ((sign & 256) != 0 ? -1 : 1);
          var i0 = 0, i1 = 0, il = 0, j0 = 0, j1 = 0, jl = 0;
          var state_il, state_i0, state_i1;
          for (var i0 = 0; i0 < stateSize; i0++) {
            il = (i0 - 1) % stateSize; if (il < 0) il += stateSize;
            i1 = (i0 + 1) % stateSize;
            state_il = state0[il];
            state_i0 = state0[i0];
            state_i1 = state0[i1];
            for (var j0 = 0; j0 < stateSize; j0++) {
               jl = (j0 - 1) % stateSize; if (jl < 0) jl += stateSize;
               j1 = (j0 + 1) % stateSize;
               // Rule layout
               // +----+-----+-----+
               // | 64 | 128 | 256 |
               // +----+-----+-----+
               // | 32 |  1  |  2  |
               // +----+-----+-----+
               // | 16 |  8  |  4  |
               // +----+-----+-----+
               v = r64*state_il[jl] + r128*state_il[j0] + r256*state_il[j1] +
                   r32*state_i0[jl] +   r1*state_i0[j0] +   r2*state_i0[j1] +
                   r16*state_i1[jl] +   r8*state_i1[j0] +   r4*state_i1[j1];
               state1[i0][j0] = ((v%modulus)+modulus)%modulus;
            }
          }
          this.curState ^= 1;
          this.setState({ruleStep: this.state.ruleStep + 1, patternName: "unknown"});
          return false;
        },
        reverseQuadrupleRuleCell4: function() {
          var base = this.state.base;
          var modulus = this.state.modulus;
          var stateSize = this.state.stateSize;
          var state = this.stateCells[this.curState^1];
          var reversible_state = this.stateCells[this.curState];
          var rule = this.state.rule;
          var sign = this.state.sign;
          var r1 = ((rule & 1) != 0 ? 1 : 0) * ((sign & 1) != 0 ? -1 : 1);
          var r2 = ((rule & 2) != 0 ? 1 : 0) * ((sign & 2) != 0 ? -1 : 1);
          var r4 = ((rule & 4) != 0 ? 1 : 0) * ((sign & 4) != 0 ? -1 : 1);
          var r8 = ((rule & 8) != 0 ? 1 : 0) * ((sign & 8) != 0 ? -1 : 1);
          var i0, i1, j0, j1, s11;
          for (i0 = 0; i0 < stateSize-1; i0++) {
            i1 = i0 + 1;
            for (j0 = 0; j0 < stateSize-1; j0++) {
              j1 = j0 + 1;
              // Quadruple rule layout:
              //      j0 | j1
              //    +----+----+
              // i0 | r1 | r2 |
              // ---+----+----+
              // i1 | r8 | r4 |
              //    +----+----+
              // solves s11 from (r1*s00 + r2*s01 + r4*s11 + r8*s10 == rs00) (mod modulus)
              s11 = (reversible_state[i0][j0] - r1*state[i0][j0] - r2*state[i0][j1] - r8*state[i1][j0])*r4;
              state[i1][j1] = ((s11%modulus)+modulus)%modulus;
            }
          }
          this.curState ^= 1;
          this.setState({ruleStep: this.state.ruleStep-1, patternName: "unknown"});
          return false;
        },
        digitReversalPermutation: function(permutate) {
          var base = this.state.base;
          var stateSize = this.state.stateSize;
          var digitCount = Math.round(log(stateSize, base));
          var state0 = this.stateCells[this.curState];
          var state1 = this.stateCells[this.curState ^ 1];
          var ri = new Array(stateSize);
          var rj = new Array(stateSize);
          for (var n = 0; n < stateSize; n++) {
            ri[n] = permutate.rows ? digitalReverse(n, digitCount, base) : n;
            rj[n] = permutate.cols ? digitalReverse(n, digitCount, base) : n;
          }
          for (var i = 0; i < stateSize; i++)
            for (var j = 0; j < stateSize; j++)
              state1[ri[i]][rj[j]] = state0[i][j];
          this.curState ^= 1;
          this.setState({patternName: "unknown"});
        },
        quadrupleDigitReversalPermutation: function(permutate) {
          var base = this.state.base;
          var stateSize = this.state.stateSize;
          var halfSize = Math.floor(stateSize / 2);
          if (!isIntegerApproximation(log(halfSize, base))) {
            throw "Invalid state size";
          }
          var digitCount = Math.round(log(halfSize, base));
          var state0 = this.stateCells[this.curState];
          var state1 = this.stateCells[this.curState ^ 1];
          var ri = new Array(halfSize);
          var rj = new Array(halfSize);
          for (var n = 0; n < halfSize; n++) {
            ri[n] = permutate.rows ? digitalReverse(n, digitCount, base) : n;
            rj[n] = permutate.cols ? digitalReverse(n, digitCount, base) : n;
          }
          for (var i = 0; i < halfSize; i++)
            for (var j = 0; j < halfSize; j++) {
              state1[ri[i]][rj[j]] = state0[i][j];
              state1[ri[i]+halfSize][rj[j]] = state0[i+halfSize][j];
              state1[ri[i]][rj[j]+halfSize] = state0[i][j+halfSize];
              state1[ri[i]+halfSize][rj[j]+halfSize] = state0[i+halfSize][j+halfSize];
            }
          this.curState ^= 1;
          this.setState({patternName: "unknown"});
        },
        digitReversalPermutationRowsCols: function(event) {
          this.digitReversalPermutation({rows: true, cols: true});
          this.setState({isDigitReversalPermutationRowsColsWasApplied: !this.state.isDigitReversalPermutationRowsColsWasApplied});
          return false;
        },
        digitReversalPermutationRows: function(event) {
          this.digitReversalPermutation({rows: true, cols: false});
          this.setState({isDigitReversalPermutationRowsWasApplied: !this.state.isDigitReversalPermutationRowsWasApplied});
          return false;
        },
        quadrupleDigitReversalPermutationRowsCols: function(event) {
          this.quadrupleDigitReversalPermutation({rows: true, cols: true});
          this.setState({isQuadrupleDigitReversalPermutationRowsColsWasApplied: !this.state.isQuadrupleDigitReversalPermutationRowsColsWasApplied});
          return false;
        },
        quadrupleDigitReversalPermutationRows: function(event) {
          this.quadrupleDigitReversalPermutation({rows: true, cols: false});
          this.setState({isQuadrupleDigitReversalPermutationRowsWasApplied: !this.state.isQuadrupleDigitReversalPermutationRowsWasApplied});
          return false;
        },
        patternGrouping: function(permutate) {
          var base = this.state.base;
          var stateSize = this.state.stateSize;
          var state0 = this.stateCells[this.curState];
          var state1 = this.stateCells[this.curState ^ 1];
          var pi = new Array(stateSize);
          var pj = new Array(stateSize);
          for (var n = 0; n < stateSize; n++) {
            pi[n] = permutate.rows ? patternGrouping(n, stateSize, base) : n;
            pj[n] = permutate.cols ? patternGrouping(n, stateSize, base) : n;
          }
          for (var i = 0; i < stateSize; i++)
            for (var j = 0; j < stateSize; j++)
              state1[pi[i]][pj[j]] = state0[i][j];
          this.curState ^= 1;
        },
        patternGroupingRows: function(event) {
          var base = this.state.base;
          var stateSize = this.state.stateSize;
          var digitCount = Math.round(log(stateSize, base));
          this.patternGrouping({rows: true, cols: false});
          this.setState({patternGroupingRowsStep: (this.state.patternGroupingRowsStep + 1) % digitCount, patternName: "unknown"});
          return false;
        },
        patternGroupingRowsCols: function(event) {
          var base = this.state.base;
          var stateSize = this.state.stateSize;
          var digitCount = Math.round(log(stateSize, base));
          this.patternGrouping({rows: true, cols: true});
          this.setState({patternGroupingRowsColsStep: (this.state.patternGroupingRowsColsStep + 1) % digitCount, patternName: "unknown"});
          return false;
        },
        handleCanvaseMouseDown: function(event) {
          if (event.button != 0)
            return;
          var pos = getMousePos(this.refs.stateCanvas.getDOMNode(), event);
          var scale = this.state.scale;
          var x = Math.floor(pos.x/scale);
          var y = Math.floor(pos.y/scale);
          this.stateCells[this.curState][y][x] = this.state.modulus-1;
          this.setState({patternName: "unknown"});
        },
        handleModulusChange: function(event) {
          var modulus = parseInt(event.target.value);
          if (modulus == NaN) // FIXME
             modulus = 2;
          //var modulus = event.target.value;
          this.setState({modulus: modulus, patternName: "unknown"});
        },
        handleBaseChange: function(event) {
          var base = parseInt(event.target.value);
          if (base == NaN) // FIXME
             base = 2;
          this.setState({
            base: base, 
            patternName: "unknown",
            patternGroupingRowsStep: 0,
            patternGroupingRowsColsStep: 0,
          });
        },
        handlePatternChange: function(event) {
          this.setPattern(event.target.value);
        },
        setStateSize: function(stateSize) {
          var state0 = createArray(stateSize, stateSize);
          var state1 = createArray(stateSize, stateSize);
          for (var i = 0; i < stateSize; i++)
            for (var j = 0; j < stateSize; j++) {
               state0[i][j] = 0;
               state1[i][j] = 0;
            }
          this.stateCells = [state0, state1];
          this.setState({
            stateSize: stateSize,
            patternName: "empty",
            ruleStep: 0,
            isDigitReversalPermutationRowsWasApplied: false,
            isDigitReversalPermutationRowsColsWasApplied: false,
            isQuadrupleDigitReversalPermutationRowsWasApplied: false,
            isQuadrupleDigitReversalPermutationRowsColsWasApplied: false,
            patternGroupingRowsStep: 0,
            patternGroupingRowsColsStep: 0,
          });
        },
        handleSizeChange: function(event) {
          var stateSize = parseInt(event.target.value);
          this.setStateSize(stateSize);
        },
        handleScaleChange: function(event) {
          var scale = parseInt(event.target.value);
          this.setState({scale: scale});
        },
        handleRuleSignChange: function(rule, sign) {
          this.setState({rule: rule, sign: sign});
        },
        makeImage: function() {
          var dataURL = this.refs.stateCanvas.getDOMNode().toDataURL();
          this.setState({imageDisplay: "block", imageSrc: dataURL});
          return false;
        },
        componentDidMount: function() {
          console.log("componentDidMount %s", this.refs.stateCanvas);
          this.setPattern(this.state.patternName);
          this.renderState();
        },
        componentDidUpdate: function() {
          console.log("componentDidUpdate: size=%d scale=%d", this.state.stateSize, this.state.scale);
          this.renderState();
        },
        isDisplayableSize: function(size) {
          var scale = this.state.scale;
          return size*scale <= maxCanvasSize && size*scale > 1;
        },
        isDisplayableScale: function(scale) {
          var stateSize = this.state.stateSize;
          return stateSize*scale <= maxCanvasSize && stateSize*scale > 1;
        },
        render: function() {
          var base = this.state.base;
          var modulus = this.state.modulus;
          var stateSize = this.state.stateSize;
          var scale = this.state.scale;
          var stateSizes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(function(power) { return {value: Math.pow(base, power), power: power}; }).concat(
                           [10, 50, 100, 200].map(function(size) { return {value: size}; }));
          var scales = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 40];
          var BorD = base == 2 ? "B" : "D";
          var BitOrDigit = base == 2 ? "Bit" : "Digit";
          return <div>
            <div>
                <label>Base: </label><input type="number" min="2" max={maxBase} value={base} onChange={this.handleBaseChange}/>
                <label>Modulus: </label><input type="number" min="2" max={maxModulus} value={modulus} onChange={this.handleModulusChange}/>
                <label>State size: <select onChange={this.handleSizeChange} value={stateSize}>
                  // Will selected when stateSize size is non-standard (e.g. size defined by query_string)
                  <option disabled={true} value={stateSize}>{"Actual size is "+stateSize}</option>
                  {stateSizes.map(function(size) {
                      return <HidingOption
                        visible={this.isDisplayableSize(size.value)}
                        value={size.value}
                        text={size.power ? size.value+" ("+base+"^"+size.power+")" : size.value } />;
                    }, this)}
                </select></label>
                <label>Scale: <select onChange={this.handleScaleChange} value={scale}>
                  {scales.map(function(scale) {
                      return <HidingOption
                        visible={this.isDisplayableScale(scale)}
                        value={scale}
                        text={scale+"x (view size is "+ scale*stateSize +")"} />;
                    }, this)}
                </select></label>
                <label>Pattern: <select onChange={this.handlePatternChange} value={this.state.patternName}>
                  // Will selected when pattern will be altered
                  <option disabled={true} value="unknown">(unknown)</option>
                  {ReactApplication.patternNames.map(function(patternName) {
                      var pattern = ReactApplication.patterns[patternName];
                      var title = pattern.titlefn ? pattern.titlefn(base) : pattern.title;
                      return <option value={patternName}>{title}</option>;
                    }, this)}
                </select></label>
                <div>
                  <input type="submit" onClick={this.applyRule} value="Apply rule"/>
                  <input type="submit"
                         disabled={(this.state.rule & 4) == 0}
                         onClick={this.reverseQuadrupleRuleCell4}
                         value="Reverse rule (1,2,4,8)"/>
                  <span>Step: {this.state.ruleStep}</span>
                  <input style={IndicatorStyle[this.state.isDigitReversalPermutationRowsColsWasApplied]}
                         disabled={!isIntegerApproximation(log(stateSize, base))}
                         type="submit" onClick={this.digitReversalPermutationRowsCols}
                         value={BorD+"RP(x,y)"} title={BitOrDigit+"-Reversal Permutation (rows and columns)"} />
                  <input style={IndicatorStyle[this.state.isDigitReversalPermutationRowsWasApplied]}
                         disabled={!isIntegerApproximation(log(stateSize, base))}
                         type="submit" onClick={this.digitReversalPermutationRows}
                         value={BorD+"RP(y)"} title={BitOrDigit+"-Reversal Permutation (rows only)"}/>
                  <input style={IndicatorStyle[this.state.isQuadrupleDigitReversalPermutationRowsColsWasApplied]}
                         disabled={!isIntegerApproximation(log(Math.floor(stateSize/2), base))}
                         type="submit" onClick={this.quadrupleDigitReversalPermutationRowsCols}
                         value={"4"+BorD+"RP(x,y)"} title={"Quadruple "+BitOrDigit+"-Reversal Permutation (rows and columns)"} />
                  <input style={IndicatorStyle[this.state.isQuadrupleDigitReversalPermutationRowsWasApplied]}
                         disabled={!isIntegerApproximation(log(Math.floor(stateSize/2), base))}
                         type="submit" onClick={this.quadrupleDigitReversalPermutationRows}
                         value={"4"+BorD+"RP(y)"} title={"Quadruple "+BitOrDigit+"-Reversal Permutation (rows only)"}/>
                  <input style={IndicatorStyle[this.state.patternGroupingRowsColsStep != 0]}
                         disabled={!isIntegerApproximation(log(Math.floor(stateSize), base))}
                         type="submit" onClick={this.patternGroupingRowsCols}
                         value={"PG (x,y) ["+this.state.patternGroupingRowsColsStep+"]"} title="Pattern Grouping (rows and columns)"/>
                  <input style={IndicatorStyle[this.state.patternGroupingRowsStep != 0]}
                         disabled={!isIntegerApproximation(log(Math.floor(stateSize), base))}
                         type="submit" onClick={this.patternGroupingRows}
                         value={"PG (y) ["+this.state.patternGroupingRowsStep+"]"} title="Pattern Grouping (rows only)"/>
                </div>
            </div>
            <div className="container">
              <div className="rule-column">
                 <RuleSignEditor rule={this.state.rule} sign={this.state.sign} onChange={this.handleRuleSignChange} />
              </div>
              <div className="view-column">
                <canvas ref="stateCanvas" width={stateSize*scale} height={stateSize*scale} onMouseDown={this.handleCanvaseMouseDown} >
                </canvas>
              </div>
              <div className="clear"></div>
            <div>
              <input type="submit" onClick={this.makeImage} value="Make image"/>
              <div style={{display: this.state.imageDisplay}}>
                Right click on image to save<br/>
                <img src={this.state.imageSrc} alt="Right click to save me" /></div>
            </div>
          </div>
          </div>;

        }
      });
      React.renderComponent(
          <ReactApplication />,
          document.getElementById('container')
      );
    </script>
    <footer class="footer">
      <p>Copyright © 2014 Sergey Shishmintzev. Code released under the <a href="https://github.com/x-or/tdacawam/blob/gh-pages/LICENSE">MIT license</a>.</p>
      <p>GitHub <a href="http://github.com/x-or/tdacawam">Project</a></p>
    </footer>
  </body>
</html>

